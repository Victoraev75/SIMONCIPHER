# -*- coding: utf-8 -*-
"""MultGalois.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qGrZD9-5tdAlYv4VC3tpS6YhVnC09krI
"""

# Puedes correr solo la parte anterior para que compruebes que en efecto la reduccion es correcta
# ===========================================================================================================
# import numpy as np

# P = [ 1, 0, 0, 1, 1]
# A = [ 1, 1, 1, 1]
# B = [ 1, 1, 1, 0]

# gx = np.poly1d(A)
# hx = np.poly1d(B)
# print(gx,"\n",hx)

# # multiplica A * B
# M = np.polymul(A,B)
# mx = np.poly1d(M)
# print("Producto: \n", mx)

# # divide the polynomials
# q, r = np.polydiv(M, P)
# Rbin = r % 2 
# rx = np.poly1d(Rbin)


# print("Reduccion: \n", rx)

# ======================================================================================================================

# Esta es la funcion y libreria necesaria, si te fijas no es necesario especificarle el tama√±o del vector
import numpy as np

def MGF( A, B, P):
  M = np.polymul(A,B)
  q, r = np.polydiv(M, P)
  return r % 2

# Aqui me invento dos polinomios de 8 bits pero igual lo puedes modificar para 128
Pol1, Pol2 = [0,1,0,1, 0,1,1,1], [1,0,0,0, 0,0,1,1]
# for i in range(8):
#   Pol1.append(i % 3 + 1)
#   Pol2.append(i % 4 - 1 )

#print(Pol1,"\n",Pol2)
#El polinomio de reduccion es: 0x11B
Primitiva = [ 1,0,0,0,1,1,0,1,1 ]

# Aqui esta el resultado expresado como un vector con valores flotantes al final hay que pasarlo a 0 y 1.
Redux = MGF( Pol1, Pol2, Primitiva )
print(Redux)
for x in Redux:
  print(int(x), end="")